/*Syed Ahmed Hassan Zaidi
Readme.txt
CPSC 418
10150285*/

Files Submitted:

	1) Client.java - most of the code
	2) Server.java - only debug code added.
	3) ServerThread.java - most of the code
	4) CryptoUtilities.java - untouched/Copy of file provided by the Prof.
	5) source (editable) - used for testing purposes.
	6) destination (editable) - used for testing purposes.

How to compile: 
	Open cmd, browse to directory where the program is stored. Type in "javac *.java" to compile all the
	files in one go.
Tested:
	Tested on cpsc.linux.ucalgary.ca
How to run:
	Open two instances of cmd from the directory where the files are stored. Follow the following steps:
	1) In one instance, type in "java Server XXXX" or "java Server XXXX debug" to run in debug mode. XXXX refers to port number and must be 4 digits long.
	2) In the second instance (seperate), type in "java Client Y.Y.Y.Y XXXX" or "java Client Y.Y.Y.Y XXXX debug" to run in debug mode. The value Y.Y.Y.Y
		is listed on the Server's cmd instance and so is the XXXX (port #).
	3) The diffi-hell man key exchange algorithm will run and key exchange will occur. Wait for it to end and then proceed with source and destination.
	4) For source: type in Source. The program works specifically for file name source as I had problems trying to implement it abstractly.
	5) For destination: type in Destination. The program works specifically for file name source as I had problems trying to implement it abstractly.
	6) The file will be encrypted and sent to the server. It will wait for response from Server. If debug mode is on, then you will see the screen tell you
		about the process.
	7) Go to Server's instance, and type in the same seed.
	8) File will be checked then decrypted. If you are in debug mode, you will see the process.
	9) An acknowledgement will be sent to the Client who was waiting. 
	10) On the Client screen, you will see if it was verified or unverified.

Solution:
	A solution has been crafted as per the precieved requirements of the question. No additional effort has been put in.

	 		
Client.java:
Changes made to only the following function(s)
	public void getKey(): 
			The client connects to the Server and proceeds with the Key Exchange protocol. The client first generates a Sophie Germain prime p
			 by using the method as defined in the assignment sheet. Basically, using a do while loop the algorithm generates a random 1023 BigInteger which is 
			 probably prime (BigInteger.probablePrime(1023, rand) where rand is Random). This 1023 BigInteger is q and I use the fact that p= 2q +1
			returns a prime P. With a do while loop, there is iteration first and then the condition checking. The emphasis of doing it this way is
			that we get to do one less iteration then a normal while loop. Once we have found, p we will find a primitive root g using primitive root
			test discussed in class. The test is done with a while loop where we initilize 'g' with 2(BigInteger) and check for both g^(p-1)/2 mod p = q 
			and g^(p-1)/q mod p = 2. Using the compareTo method defined in BigInteger we check if it is equal to q and 2 and if the answer is NOT equal 
			to 0 (meaning not equal to each other) then g is a primitive root of p. Once we have found the g, we proceed to send p and g to the server.
			The program uses the function .toByteArray() on 'g' and 'p' to convert it to a byte array and send it to the server. 
			While it is waiting for a response from a server, We generate our g^a, where we find an 'a'(BigInteger) such that it is between 0 and p-2. It is basically 
			defined the same as q but it will not be probablePrime. Once we have found g^a we will send it to the server. Once we get a response from the 
			server after sending 'p' and g, we will recieve g^b. We proceed to generate g^ab by raising the recieved g^b with our 'a'. Once we have our g^ab, we pass it
			to CryptoUtilities method key_from_seed(byte[]) where our key is generated.

The Client will work the same way as it works in Assignment 2 and thus the whole structure of the file is irrelevant to describe here.
			      
	
ServerThread.java:
Changes made to only the following function(s)
	public void getKey():
			The server waits to recieve p and g generated by the Client. It reads it as byte array and generates a BigInteger by using BigInteger(byte[]).
			Once it has recieved p and g, it will generate a 'b'between 0 and p-2. Once b has been generated it will raise the recieved b to the power of b (g^b)
			and sends it to Client as a byte array. It will also recieve an 'a' in byte array form and will generate a BigInteger based on that. It will then generate
			g^ba by using the 'a' it has recieved from the Client and raising it to g^b the Server has generated itself. Once it has generated g^ab which will be the same
			as the client, we pass it to CryptoUtilities method key_from_seed(byte[]) where our key is generated.

The ServerThread will work the same way as it works in Assignment 2 and thus the whole structure of the file is irrelevant to describe here.			      
Server.java:
	Untouched!

CryptoUtilities.java:
	Untouched!